<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>层次模型</title>
    <style>
        body {
            background-color: #000;
        }
    </style>
</head>
<body>
    <canvas id="webglcanvas" width="500" height="500"></canvas>
    <div id="info">
        <span>keyscontrol：</span>
        <span>↑</span>
        <span>↓</span>
        <span>←</span>
        <span>→</span>
    </div>

    <script src="./examples/lib/webgl-utils.js"></script>
    <script src="./examples/lib/webgl-debug.js"></script>
    <script src="./examples/lib/cuon-utils.js"></script>
    <script src="./examples/lib/cuon-matrix.js"></script>


    <script id="vertexshader" type="text">
        attribute float a_PointSize;
        attribute vec3 a_Position;
        attribute vec3 a_Normal;
        attribute vec4 a_Color;

        uniform mat4 u_VPMatrix;

        varying vec4 v_Color;

        void main(){
            v_Color = a_Color;

            gl_Position = vec4(a_Position, 1.0);
            gl_PointSize = a_PointSize;
        }
    </script>
     <script id="fragmentshader" type="text">
        precision mediump float;

        varying vec4 v_Color;

        void main(){
            gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
        }

     </script>
     
    <script>

        const VSHADER_SOURCE = document.getElementById('vertexshader').innerHTML
        const FSHADER_SOURCE = document.getElementById('fragmentshader').innerHTML

        function main() {
            // Retrieve <canvas> element
            var canvas = document.getElementById('webglcanvas');

            // Get the rendering context for WebGL
            var gl = getWebGLContext(canvas);
            if (!gl) {
                console.log('Failed to get the rendering context for WebGL');
                return;
            }
            // Initialize shaders
            if (!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)) {
                console.log('Failed to intialize shaders.');
                return;
            }

            const a_PointSize = gl.getAttribLocation(gl.program, 'a_PointSize')
            gl.vertexAttrib1f(a_PointSize, 1)

  


            initViewProj(canvas, gl)

            drawBoxes(gl)

        }

        function initViewProj(canvas, gl) {
            const viewProjMatrix = new Matrix4()
            viewProjMatrix.setPerspective(50, canvas.width / canvas.height, 1.0, 100.0)
            viewProjMatrix.lookAt(1.0, 3.0, 3.0,  0.0, 0.0, 0.0,  0.0, 1.0, 0.0)
            const u_VPMatrix = gl.getUniformLocation(gl.program, 'u_VPMatrix')
            gl.uniformMatrix4fv(u_VPMatrix, false, viewProjMatrix.elements)
        }




        function drawBoxes(gl) {

            // joint0
            const joint0 = createBox(1, 1, 1, [1, 0, 0])
            initVertexBuffers(gl, joint0.vertex, joint0.color, joint0.normal, joint0.index)

            console.log(joint0)

            
            gl.enable(gl.DEPTH_TEST)
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.clearColor(0.9, 0.9, 0.9, 1.0);

            gl.drawElements(gl.TRIANGLES, joint0.index.length, gl.UNSIGNED_BYTE, 0)
        }

        function initVertexBuffers(gl, vertex, color, normal, index) {

            // a_Position
            const buffer0 = gl.createBuffer()
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer0)
            gl.bufferData(gl.ARRAY_BUFFER, vertex, gl.STATIC_DRAW)
            const a_Position = gl.getAttribLocation(gl.program, 'a_Position')
            gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, 0, 0)
            gl.enableVertexAttribArray(a_Position)

            // a_Color
            const buffer1 = gl.createBuffer()
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer0)
            gl.bufferData(gl.ARRAY_BUFFER, color, gl.STATIC_DRAW)
            const a_Color = gl.getAttribLocation(gl.program, 'a_Color')
            gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, 0, 0)
            gl.enableVertexAttribArray(a_Position)

            // a_Normal
            const buffer2 = gl.createBuffer()
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer0)
            gl.bufferData(gl.ARRAY_BUFFER, normal, gl.STATIC_DRAW)
            const a_Normal = gl.getAttribLocation(gl.program, 'a_Normal')
            gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, 0, 0)
            gl.enableVertexAttribArray(a_Position)

            // index
            const buffer3 = gl.createBuffer()
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer3);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, index, gl.STATIC_DRAW);
        }

        function createBox(width, height, length, col) {
            const vertices = [
                [-width/2, -height/2, length/2], // A 0
                [width/2, -height/2, length/2], // B 1
                [width/2, height/2, length/2], // C 2
                [-width/2, height/2, length/2], // D 3
                [-width/2, -height/2, -length/2], // E 4
                [width/2, -height/2, -length/2], // F 5
                [width/2, height/2, -length/2], // G 6
                [-width/2, height/2, -length/2] // H 7
            ]
            const colors = [
                col, col, col, col, col, col
            ]

            const vertex = new Float32Array([
                ...vertices[0], ...vertices[1], ...vertices[2], ...vertices[3],
                ...vertices[1], ...vertices[5], ...vertices[6], ...vertices[2],
                ...vertices[5], ...vertices[4], ...vertices[7], ...vertices[6],
                ...vertices[4], ...vertices[0], ...vertices[3], ...vertices[7],
                ...vertices[3], ...vertices[2], ...vertices[6], ...vertices[7],
                ...vertices[0], ...vertices[1], ...vertices[5], ...vertices[4],
            ])
            const color = new Float32Array([
                ...colors[0], ...colors[0], ...colors[0], ...colors[0], 
                ...colors[1], ...colors[1], ...colors[1], ...colors[1], 
                ...colors[2], ...colors[2], ...colors[2], ...colors[2], 
                ...colors[3], ...colors[3], ...colors[3], ...colors[3], 
                ...colors[4], ...colors[4], ...colors[4], ...colors[4], 
                ...colors[5], ...colors[5], ...colors[5], ...colors[5], 

            ])
            const normal = new Float32Array([
                0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0,
                1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0,
                0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0,
                -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0,
                0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0,
                0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0,
            ])
            const index = new Uint8Array([
                0, 1, 2, 0, 3, 2,
                4, 5, 6, 4, 7, 6,
                8, 9, 10, 8, 11, 10,
                12, 13, 14, 12, 15, 14,
                16, 17, 18, 16, 19, 18,
                20, 21, 22, 20, 23, 22,
            ])

            return {
                vertex, color, normal, index
            }
        }

        main()
    </script>
</body>
</html>